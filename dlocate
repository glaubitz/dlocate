#!/bin/bash
#
# original script by Jim Pick <jim@jimpick.com>, GPL'd of course
# many changes and enhancement by Craig Sander <cas@taz.net.au>
#
# hacked by cas to use case instead of if/elif/fi
# hacked by cas to add '-ls' option.  also added error checking for
# -L and -ls options.
# hacked by cas to add '-conf' and '-lsconf' options.
# hacked by cas to add '-md5sum' and '-md5check' options.
# hacked by cas to add '-man' option.
# hacked by cas to add '-s' option (requires grep-dctrl).
# hacked by cas to support multiple string/package arguments
# hacked by cas to add simplistic emulation of 'dpkg -l'


config(){
    PROGRAM=${0##*/}
    VERSION='1.1'

    DLOCATEDB=/var/lib/dlocate/dlocatedb
    DPKGLIST=/var/lib/dlocate/dpkg-list
    DPKG_INFO=/var/lib/dpkg/info

    # check whether compression is enabled
    COMPRESS_DLOCATE='0'
    [[ -r /etc/default/dlocate ]] && . /etc/default/dlocate
    [[ $COMPRESS_DLOCATE = 1 ]] && GREP='zgrep' || GREP='grep'

    # default to extended regexp
    DCTRL_RE_TYPE='-e'
    RE_TYPE='-E'
    RE_SEPARATOR='|'

    OPTION='DEFAULT'

    # default to debug/verbose OFF
    VERBOSE='0'

    # default to case-sensitive
    IGNORE_CASE=

    # default to non word-based searches
    WORD_RE=

    # output filters for -S and DEFAULT option
    OUTPUT_FILTER=
}

dlocate_help(){
    cat <<-__EOF__
	Usage: $PROGRAM [option...] [command] [PATTERN...]

	Commands:
	  DEFAULT/none PATTERN   list records that match either package or files names
	  -p           PATTERN   list records that match packages
	  -S           PATTERN   list records that match filenames
	  -e           STRING    list package that file belongs to
	  -o           COMMAND   list package that command belongs to

	  -f           package   list all files in package
	  -L           package   list all contents of package
	  -l           package   regexp-enhanced emulation of 'dpkg -l'
	  -s           package   print package's status
	  -ls          package   'ls -ldF' of all package contents
	  -du          package   'du -sck' of all package contents
	  -conf        package   list conffiles in package
	  -lsconf      package   'ls -ldF' of conffiles in package
	  -md5sum      package   list package's md5sums (if any)
	  -md5check    package   check package's md5sums (if any)
	  -man         package   list package's man pages (if any)
	  -lsman       package   list full paths of man pages
	  -lsbin       package   list full paths of executable files
	  -lscmd       package   list names of executable files on PATH
	  -k                     list installed kernel & related packages
	  -K                     detailed list of installed kernel & related packages

	  --                    stop processing commands and options.  remainder of
	                        command-line is filename(s)


	The -l, and -S commands are approximately the same as the equivalent dpkg
	options except that the search is performed using regular expressions
	rather than fixed strings.

	Options

	  --filename-only        only output file names when searching for files
	  --package-only         only output package names when searching for files

	Regular Expression Options (see grep(1) for details):

	  -E, --extended-regexp
	  -F, --fixed-strings
	  -G, --basic-regexp
	  -P, --perl-regexp

	  -w, --word-regexp     restrict matches to whole words
	  -i, --ignore-case     case-insensitive match

	Miscellaneous Options:

	  -h, -H, --help          display this help message and exit.
	  -V, --version           display dlocate's version number and exit.
	  -v, --verbose, --debug  verbose/debug output
	__EOF__
    exit 0
}

dlocate_error(){
    cat <<-__EOF__ >&2
	$PROGRAM: unknown option '$1'

	Use: '$PROGRAM -- $1' if you want to search for '$1'
	__EOF__
    exit 1
}

dlocate_version(){
    echo "$PROGRAM $VERSION"
    exit 0
}

error(){
    echo "ERROR: $*" >&2
}

fatal(){
    error "$*"
    echo >&2
    exit 1
}

output_filter(){
    [[ $VERBOSE -eq 1 ]] && echo "OUTPUT FILTER: $OUTPUT_FILTER"

    case "$OUTPUT_FILTER" in
        'filenames')
            local output=$(awk '{ print $NF }')
            ;;

        'packages')
            # show only package names
            local output=$(awk '{ if ($1=="diversion"){ print $3 } else { sub(":.*$", ""); print } }')

            # include diversion from/to string
            # local output=$(sed 's/: [^ ]\+$//')
            ;;

        *)
            local output=$(cat)
            ;;
    esac

    [[ -n $output ]] && sort -u <<<"$output"
}

parse(){
    local LAST_OPT='0'

    for argument in "$@"; do
        if [[ $LAST_OPT -eq 1 ]]; then
            PKGS+=("$argument")
        else
            case "$argument" in
                '--')
                    LAST_OPT='1'
                    ;;

                ''|'-h'|'-H'|'--help')
                    dlocate_help
                    ;;

                '-V'|'--version')
                    dlocate_version
                    ;;

                '-d'|'--debug'|'-v'|'--verbose')
                    VERBOSE='1'
                    ;;

                '-e'|'-o')
                    OPTION="$argument"
                    OUTPUT_FILTER='packages'
                    ;;

                '-k'|'-K')
                    OPTION="$argument"
                    ;;

                '-conf'|'-du'|'-f'|'-l'|'-L'|'-ls'|'-lsbin'|'-lscmd'|'-lsconf'|'-lsman'|'-man'|'-md5check'|'-md5sum'|'-s'|'-S')
                    OPTION="$argument"
                    ;;

                '-p')
                    OPTION="$argument"
                    OUTPUT_FILTER='packages'
                    ;;

                '-i'|'--ignore-case')
                    IGNORE_CASE='-i'
                    ;;

                '-E'|'--extended-regexp')
                    RE_TYPE='-E'
                    DCTRL_RE_TYPE='-e'
                    RE_SEPARATOR='|'
                    ;;

                '-F'|'--fixed-strings')
                    RE_TYPE='-F'
                    RE_SEPARATOR='\n'
                    ;;

                '-G'|'--basic-regexp')
                    RE_TYPE='-G'
                    DCTRL_RE_TYPE='-r'
                    RE_SEPARATOR='\\|'
                    ;;

                '-P'|'--perl-regexp')
                    RE_TYPE='-P'
                    RE_SEPARATOR='|'
                    ;;

                '-w'|'--word-regexp')
                    WORD_RE='-w'
                    ;;

                '--filename-only')
                    OUTPUT_FILTER='filenames'
                    ;;

                '--package-only')
                    OUTPUT_FILTER='packages'
                    ;;

                -*)
                    dlocate_error "$argument"
                    ;;

                *)
                    PKGS+=("$argument")
                    ;;
            esac
        fi
    done
}

running(){
    echo "RUNNING: $*"
}

verbosity(){
    cat <<-__EOF__
	------------------------------
	[EXECUTION ENVIRONMENT]
	PKGS: ${PKGS[@]}
	RE_SEPARATOR: $RE_SEPARATOR
	FILES_REGEXP: $FILES_REGEXP
	PKGS_REGEXP: $PKGS_REGEXP
	OPTION: $OPTION
	------------------------------
	__EOF__
}

# load configuration defaults
config

# parse arguments and options
parse "$@"

# show help if package list is empty
(( ${#PKGS[@]} == 0 )) && [[ ! $OPTION =~ ^-(k|K)$ ]] && dlocate_help

if [[ $OPTION =~ ^(-e|-o)$ ]]; then

    # ensure we're not searching for multiple files or commands
    if (( ${#PKGS[@]} > 1 )); then
        fatal "'$OPTION' option only supports queries with one STRING"
    fi

    FILES_REGEXP=${PKGS[0]}

else

    # compose a regex string from PKGS
    PKGS_REGEXP=$(sed "s/ /$RE_SEPARATOR/g" <<<"${PKGS[@]}")

    # put the package names in a regex group
    FILES_REGEXP="($PKGS_REGEXP)"

    # match filenames on word boundaries if --word-regexp is enabled
    [[ $WORD_RE = '-w' ]] && FILES_REGEXP="\b$FILES_REGEXP\b"

fi

# display execution environment details
[[ $VERBOSE -eq 1 ]] && verbosity

if [[ $OPTION = 'DEFAULT' ]]; then

    # [[ $VERBOSE -eq 1 ]] && running "$GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- \"$PKGS_REGEXP\" \"$DLOCATEDB\""
    # $GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- "$PKGS_REGEXP" "$DLOCATEDB" | output_filter

    COMMAND='$GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- "$PKGS_REGEXP" "$DLOCATEDB"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND" | output_filter

    result=${PIPESTATUS[0]}

elif [[ $OPTION = '-e' || $OPTION = '-o' ]]; then

    for arg in "$@"; do
        if [[ $arg =~ ^(-E|-F|-G|-i|-P|-w|--fixed-strings|--ignore-case|--[a-z]+regexp)$ ]]; then
            fatal "$OPTION exact command searches are incompatible with regular expression options"
        fi
    done

    # determine the path of an executable
    if [[ $OPTION = '-o' ]]; then
        temp_path=$(type -P "$FILES_REGEXP")
        if [[ -n $temp_path ]]; then
            FILES_REGEXP=$temp_path
        else
            fatal "'$FILES_REGEXP' does not appear to be a valid command on the PATH"
        fi
    fi

    # determine the absolute path of a file
    SEARCH_STRING=$(readlink -e "$FILES_REGEXP")

    # PREFIX='(^[-a-zA-Z0-9_.+]+| (to|from)):'
    PREFIX=':'

    # [[ $VERBOSE -eq 1 ]] && running "$GREP $RE_TYPE -- \"$PREFIX ${SEARCH_STRING}$\" \"$DLOCATEDB\""
    # $GREP $RE_TYPE -- "$PREFIX ${SEARCH_STRING}$" "$DLOCATEDB" | output_filter

    COMMAND='$GREP $RE_TYPE -- "$PREFIX ${SEARCH_STRING}$" "$DLOCATEDB"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND" | output_filter

    result=${PIPESTATUS[0]}

elif [[ $OPTION = '-k' ]]; then

    grep-status -eP '(^linux-(image|source|headers|doc|debug)|nvidia-kernel-|.*-modules-)' | \
        grep-dctrl -n -s Package -F status ' installed' | \
        grep -Ev -- '^(lib|openser|pam|scim|tryton|wims)|-perl'

    result=$?

elif [[ $OPTION = '-K' ]]; then

    KERN_RE=$(dlocate -k | paste -sd '|')

    # [[ $VERBOSE -eq 1 ]] && running "dlocate -P -l \s($KERN_RE)\s"
    # dlocate -P -l "\s($KERN_RE)\s"

    COMMAND='dlocate -P -l "\s($KERN_RE)\s"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND"

    result=$?

elif [[ $OPTION = '-l' ]]; then

    [[ -z $COLUMNS ]] && COLUMNS=$(tput cols 2>/dev/null ||
                                   stty size 2>/dev/null | cut -d' ' -f2)

    [[ $COLUMNS -lt 80 ]] && COLUMNS=80

    (( width = ( COLUMNS - 24 ) / 4 ))

    # dpkg uses (( depth = width * 2 + 16 ))
    #
    # This limits the output to COLUMNS-2 characters and loses
    # up to 3 additional characters due to the rounding error.

    (( depth = COLUMNS - width * 2 - 6 ))

    spacer=$(head -c "$width" /dev/zero | tr '\0' '=')

    header=$(printf \
"Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Installed/Config-files/Unpacked/Failed-config/Half-installed
|/ Err?=(none)/Hold/Reinst-required/X=both-problems (Status,Err: uppercase=bad)
||/ %-${width}s %-${width}s %s
+++-${spacer}-${spacer}-${spacer}${spacer}==================\\n" \
    Name Version Description)

    body_formatted="%-2s  %-${width}.${width}s %-${width}.${width}s %-${depth}.${depth}s\\n"

    # [[ $VERBOSE -eq 1 ]] && running "$GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- $PKGS_REGEXP $DPKGLIST"

    # body=$($GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- "$PKGS_REGEXP" "$DPKGLIST" | \
    #        awk -F'\t' "{ printf \"$body_formatted\", \$1, \$2, \$3, \$4 }" |
    #        sed -e 's/ *$//g')

    COMMAND='$GREP $RE_TYPE $WORD_RE $IGNORE_CASE -- "$PKGS_REGEXP" "$DPKGLIST"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    body=$(eval "$COMMAND" | \
           awk -F'\t' "{ printf \"$body_formatted\", \$1, \$2, \$3, \$4 }" |
           sed -e 's/ *$//g')


    [[ -n $body ]] && echo -e "${header}\n${body}"

elif [[ $OPTION = '-p' ]]; then

    if [[ $RE_TYPE = '-F' ]]; then
        fatal "-F Fixed String searches are incompatible with -p"
    fi

    PREFIX='^(diversion by )?'
    POSTFIX='(:.+)?( (from|to))?: '

    [[ $RE_TYPE = '-G' ]] && PREFIX='^\(diversion by \)\?' && \
                             POSTFIX='\(:.\+\)\?\( \(from\|to\)\)\?: ' && \
                             FILES_REGEXP=$(sed 's/(/\\(/g;s/)/\\)/g' <<<"$FILES_REGEXP")

    # [[ $VERBOSE -eq 1 ]] && running "$GREP $RE_TYPE $IGNORE_CASE -- \"${PREFIX}.*${FILES_REGEXP}.*${POSTFIX}\" \"$DLOCATEDB\""
    # $GREP $RE_TYPE $IGNORE_CASE -- "${PREFIX}.*${FILES_REGEXP}.*${POSTFIX}" "$DLOCATEDB" | output_filter

    COMMAND='$GREP $RE_TYPE $IGNORE_CASE -- "${PREFIX}.*${FILES_REGEXP}.*${POSTFIX}" "$DLOCATEDB"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND" | output_filter

    result=${PIPESTATUS[0]}

elif [[ $OPTION = '-s' ]]; then

    if [[ $DCTRL_RE_TYPE = '-r' ]]; then
        DCTRL_REGEXP="^\($PKGS_REGEXP\)$"
    else
        DCTRL_REGEXP="^($PKGS_REGEXP)$"
    fi

    # [[ $VERBOSE -eq 1 ]] && running "grep-dctrl -P $DCTRL_RE_TYPE \"$DCTRL_REGEXP\" /var/lib/dpkg/status"
    # grep-dctrl -P $DCTRL_RE_TYPE "$DCTRL_REGEXP" /var/lib/dpkg/status

    COMMAND='grep-dctrl -P $DCTRL_RE_TYPE "$DCTRL_REGEXP" /var/lib/dpkg/status'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND"

    result=$?

elif [[ $OPTION = '-S' ]]; then

    if [[ $RE_TYPE = '-F' ]]; then
        fatal "-F Fixed String searches are incompatible with -S"
    fi

    # PREFIX='(^[-a-zA-Z0-9_.+]+| (to|from)):'
    PREFIX=':'

    # [[ $RE_TYPE = '-G' ]] && PREFIX='\(^[-a-zA-Z0-9_.+]\+\| \(to\|from\)\):' && \
    #                          FILES_REGEXP=$(sed 's/(/\\(/g;s/)/\\)/g' <<<"$FILES_REGEXP")
    [[ $RE_TYPE = '-G' ]] && FILES_REGEXP=$(sed 's/(/\\(/g;s/)/\\)/g' <<<"$FILES_REGEXP")

    # [[ $VERBOSE -eq 1 ]] && running "$GREP $RE_TYPE $IGNORE_CASE -- \"$PREFIX .*$FILES_REGEXP\" \"$DLOCATEDB\""
    # $GREP $RE_TYPE $IGNORE_CASE -- "$PREFIX .*$FILES_REGEXP" "$DLOCATEDB" | output_filter

    COMMAND='$GREP $RE_TYPE $IGNORE_CASE -- "$PREFIX .*$FILES_REGEXP" "$DLOCATEDB"'

    [[ $VERBOSE -eq 1 ]] &&  eval running "$COMMAND"
    eval "$COMMAND" | output_filter

    result=${PIPESTATUS[0]}

else

    for PKG in "${PKGS[@]}"; do

        search_string=$(sed 's/+/\\+/g' <<<"$PKG")
        readarray -t packages < <(find "$DPKG_INFO" -regextype posix-extended -regex "$DPKG_INFO/${search_string}(:[^.]+)?\.[^.]+" | sed 's/\.[^\.]*$//' | sort -u)
        if (( ${#packages[@]} == 0 )); then
            error "Package $PKG not installed or has no files in $DPKG_INFO."
            result=1
            continue
        elif (( ${#packages[@]} == 1 )); then
            file=${packages[0]}
        elif (( ${#packages[@]} > 1 )); then
            error "Package $PKG has multiple architectures. Please specify the full package name including architecture:"
            printf '%s\n' "${packages[@]}" >&2
            result=1
            continue
        fi

        case $OPTION in
            '-conf')
                if [[ -s $file.conffiles ]]; then
                    cat "$file.conffiles"
                    result=$?
                    continue
                else
                    error "Package $PKG has no conffiles."
                fi
                ;;

            '-du')
                if [[ -s $file.list ]]; then
                    (
                        set -o pipefail
                        xargs -a "$file.list" -r -- ls -1dF | grep -Ev '(@|/)$' | sed 's/[*=>|]$//' | xargs -d '\n' -r -- du -cks
                    )
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-f')
                if [[ -s $file.list ]]; then
                    while IFS= read -r path; do
                        if [[ -f $path ]]; then
                            echo "$path"
                        fi
                    done < "$file.list"
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-L')
                if [[ -s $file.list ]]; then
                    cat "$file.list"
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-ls')
                if [[ -s $file.list ]]; then
                    xargs -r -- ls -ldF -- < "$file.list"
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-lsbin')
                if [[ -s $file.list ]]; then
                    while IFS= read -r path; do
                        if [[ -f $path && -x $path ]]; then
                            echo "$path"
                        fi
                    done < <(dlocate -L "$PKG") | sort
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-lscmd')
                if [[ -s $file.list ]]; then
                    while IFS= read -r path; do
                        dirpath=$(dirname "$path")
                        if [[ -n $dirpath ]] && grep -Eq "(^|:)$dirpath($|:)" <<<"$PATH"; then
                            echo "${path##*/}"
                        fi
                    done < <(dlocate -lsbin "$PKG") | sort -u
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-lsconf')
                if [[ -s $file.conffiles ]]; then
                    xargs -r -- ls -ldF -- < "$file.conffiles"
                    result=$?
                    continue
                else
                    error "Package $PKG has no conffiles."
                fi
                ;;

            '-lsman')
                if [[ -s $file.list ]]; then
                    dlocate -L "$PKG" | grep -E '/man[0-9]+/'
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-man')
                if [[ -s $file.list ]]; then
                    dlocate -lsman "$PKG" | \
                        sed 's:.*/::;s/[A-Za-z]*\.gz$//;s/\(^.*\)\.\(.*\)/\2 \1/' | \
                        sort
                    result=$?
                    continue
                else
                    error "$file.list is empty."
                fi
                ;;

            '-md5check')
                if [[ -s $file.md5sums ]]; then
                    output=$(cd / && md5sum --check "$file.md5sums" 2>/dev/null)
                    if [[ -n $output ]]; then
                        output=$(grep -v ': OK' <<<"$output")
                        if [[ -n $output ]]; then
                            echo "$output"
                        else
                            echo "ALL OK"
                            result=0
                            continue
                        fi
                    fi
                else
                    error "Package $PKG has no md5sums."
                fi
                ;;

            '-md5sum')
                if [[ -s $file.md5sums ]]; then
                    cat "$file.md5sums"
                    result=$?
                    continue
                else
                    error "Package $PKG has no md5sums."
                fi
                ;;

        esac

        # this point is only reachable upon failure
        result=1

    done
fi

if [[ -n $result ]]; then
    exit "$result"
fi
